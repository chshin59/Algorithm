# BOJ 14500: 테트로미노

## 문제 정보

- **문제 이름**: 테트로미노
- **문제 번호**: 14500
- **플랫폼**: 백준 (Baekjoon Online Judge)
- **문제 링크**: [https://www.acmicpc.net/problem/14500](https://www.acmicpc.net/problem/14500)
- **난이도**: 골드 4

## 알고리즘 분류

- 구현
- 브루트포스 알고리즘

## 문제 요약

N×M 크기의 종이 위에 테트로미노 하나를 놓아서, 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 만드는 프로그램을 작성하시오. 테트로미노는 총 5가지 종류가 있으며, 회전하거나 대칭시킬 수 있다.

## 접근 방법

모든 칸에 5가지 종류의 테트로미노를 모두 놓아보며 최댓값을 찾는 브루트포스 방식으로 접근하며, DFS(깊이 우선 탐색)를 주된 탐색 방법으로 사용합니다.

1.  **기본 테트로미노 탐색 (DFS)**: 'ㅗ' 모양을 제외한 나머지 모양들은 4칸이 한 줄로 이어져 있는 형태이므로, 깊이가 4인 DFS를 통해 탐색할 수 있습니다.
  - 보드의 모든 칸 `(x, y)`에서 탐색을 시작합니다.
  - `visited` 배열을 통해 방문한 칸을 다시 방문하지 않도록 하여, 4개의 고유한 칸으로 이루어진 경로의 합을 구하고 최댓값을 갱신합니다.

2.  **'ㅗ' 모양 처리**: 해당 구현에서는 'ㅗ' 모양을 DFS 탐색 중에 별도의 로직으로 처리합니다.
  - DFS 탐색의 깊이가 2가 되었을 때, 즉 2개의 칸이 선택되었을 때(예: `A -> B`) 현재 칸 `B`를 중심으로 하는 모양을 만들기 시작합니다.
  - 현재 칸 `B`에 인접하고 아직 방문하지 않은 칸들을 `set`에 저장합니다.
  - `set`에 인접한 칸이 2개 이상 있다면, `combinations`를 사용하여 인접한 칸 2개를 선택하는 모든 조합을 구합니다.
  - 각 조합에 대해, **현재 칸 `B`의 값과 선택된 인접 칸 2개의 값을 더한 합**을 계산하여 최댓값을 갱신합니다.
